<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Encoding and decoding · Dynosaur</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;code&gt;Dynosaur&lt;/code&gt; design for codecs is based on defining &lt;em&gt;schemas&lt;/em&gt; for your&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Encoding and decoding · Dynosaur"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ovotech.github.io/dynosaur/dynosaur/"/><meta property="og:description" content="&lt;p&gt;&lt;code&gt;Dynosaur&lt;/code&gt; design for codecs is based on defining &lt;em&gt;schemas&lt;/em&gt; for your&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/dynosaur/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/dynosaur/js/scrollSpy.js"></script><link rel="stylesheet" href="/dynosaur/css/main.css"/><script src="/dynosaur/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/dynosaur/"><h2 class="headerTitle">Dynosaur</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/dynosaur/docs/overview" target="_self">Documentation</a></li><li class=""><a href="https://github.com/ovotech/dynosaur" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Documentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/dynosaur/docs/overview">Overview</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/dynosaur/docs/schema">Encoding and decoding</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Encoding and decoding</h1></header><article><div><span><p><code>Dynosaur</code> design for codecs is based on defining <em>schemas</em> for your
data, rather than your typical <code>Encoder/Decoder</code> typeclasses.
The central type of the DSL is <code>Schema[A]</code>, which you can think of as
either a representation of <code>A</code>, or a recipe for <em>both</em> encoding and
decoding <code>A</code>s to and from <code>AttributeValue</code>.</p>
<p><strong>Note:</strong>  basic familiarity with <code>cats</code> typeclasses like <code>Monoid</code> and
<code>Applicative</code> is required.</p>
<h2><a class="anchor" aria-hidden="true" id="setup"></a><a href="#setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup</h2>
<p>We are going to need the following imports:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> dynosaur.codec.<span class="hljs-type">Schema</span>
<span class="hljs-keyword">import</span> cats.implicits._
</code></pre>
<p>We will also define <code>.read</code> and <code>.write</code> helpers to run the examples
in this page, but you are not going to need them in your own code.<br>
For the time being, we will ignore potential errors, and show the
output as <code>Json</code> instead of the <code>AttributeValue</code> ADT to help with
readability.</p>
<p><details>
<summary>Click to expand</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codecs</span>[<span class="hljs-type">A</span>](<span class="hljs-params">schema: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>]</span>) </span>{
  <span class="hljs-keyword">import</span> dynosaur.codec.{<span class="hljs-type">Encoder</span>, <span class="hljs-type">Decoder</span>}
  <span class="hljs-keyword">import</span> dynosaur.model.<span class="hljs-type">AttributeValue</span>
  <span class="hljs-keyword">import</span> dynosaur.lo.codec._
  <span class="hljs-keyword">import</span> io.circe._, syntax._
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(v: <span class="hljs-type">A</span>): <span class="hljs-type">Json</span> = 
    <span class="hljs-type">Encoder</span>.fromSchema(schema)
    .write(v)
    .map(_.asJson)
    .toOption.get
    
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(v: <span class="hljs-type">Json</span>): <span class="hljs-type">A</span> = {
    <span class="hljs-keyword">for</span> {
      av &lt;- v.as[<span class="hljs-type">AttributeValue</span>].toOption
      a &lt;- <span class="hljs-type">Decoder</span>.fromSchema(schema).read(av).toOption
    } <span class="hljs-keyword">yield</span> a
  }.get
}
</code></pre>
<p></details></p>
<h2><a class="anchor" aria-hidden="true" id="quick-example"></a><a href="#quick-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quick example</h2>
<p>Given this simple ADT</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Auth</span> </span>{
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">reason: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
}
</code></pre>
<p>We define a schema for it</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> schema: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = <span class="hljs-type">Schema</span>.oneOf { alt =&gt;
  <span class="hljs-keyword">val</span> error = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>] { field =&gt;
    field(<span class="hljs-string">"reason"</span>, _.reason).map(<span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>.apply)
   }
   
  <span class="hljs-keyword">val</span> user = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>] { field =&gt;
    (
      field(<span class="hljs-string">"id"</span>, _.id),
      field(<span class="hljs-string">"name"</span>, _.name)
    ).mapN(<span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>.apply)
  }
  
  alt(error tag <span class="hljs-string">"error"</span>) |+| alt(user tag <span class="hljs-string">"user"</span>) 
}
</code></pre>
<p>Which can then be used for both encoding and decoding:</p>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> u = <span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>(<span class="hljs-number">303</span>, <span class="hljs-string">"tim"</span>)
<span class="hljs-comment">// u: Auth.User = User(303,tim)</span>
<span class="hljs-keyword">val</span> e = <span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>(<span class="hljs-string">"Unauthorized"</span>)
<span class="hljs-comment">// e: Auth.Error = Error(Unauthorized)</span>

schema.write(u)
<span class="hljs-comment">// res0: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "user" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "id" : {</span>
<span class="hljs-comment">//           "N" : "303"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "name" : {</span>
<span class="hljs-comment">//           "S" : "tim"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schema.read(schema.write(u))
<span class="hljs-comment">// res1: Auth = User(303,tim)</span>
schema.write(e)
<span class="hljs-comment">// res2: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "error" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "reason" : {</span>
<span class="hljs-comment">//           "S" : "Unauthorized"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schema.read(schema.write(e))
<span class="hljs-comment">// res3: Auth = Error(Unauthorized)</span>
</code></pre>
<p></details></p>
<p>In the rest of the document, we will only show encoding since decoding
comes for free, unless there is something specific to point out about
the behaviour of the decoder.</p>
<h2><a class="anchor" aria-hidden="true" id="motivation"></a><a href="#motivation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Motivation</h2>
<p>The typical approach most libraries use for codecs involves
<code>Encoder/Decoder</code> typeclasses, sometimes including automatic derivation.
This approach has the following drawbacks:</p>
<ul>
<li>Automatic derivation is <em>opaque</em> : you cannot easily read how your
format looks like, you need to recall the implicit mapping rules
between your data and the format.</li>
<li>Automatic derivation is <em>brittle</em>: generally harmless
transformations like rename refactoring on your data can break your
format.</li>
<li>Automatic derivation is <em>inflexible</em> : it cannot cover many useful
transformations on your format like different naming, encoding of
ADTs, flattening some records, approach to optionality and so on.</li>
<li>Juggling different formats for the same data is cumbersome.</li>
<li>On the other hand, writing explicit encoders and decoders is
annoying because you need to keep them in sync, and the required
code is similar enough to be tedious, but different enough to be error prone.<br>
Even without this duplication, the process is still made hard by the
fact that you are dealing with the practical details of traversing a
low level data structure like Json or AttributeValue.</li>
</ul>
<p>As a result, people abuse automatic derivation, and end up with either
ugly serialised data and a nice code model, or nice serialised data
and an ugly code model.<br>
The schema DSL provided by Dynosaur, on the other hand, allows you to
be flexible in how you define your serialised data, without
duplicating code for encoders and decoders, and with a declarative
focus on the <em>structure</em> of the data, rather than the traversal of a
low level representation.</p>
<h2><a class="anchor" aria-hidden="true" id="primitives"></a><a href="#primitives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Primitives</h2>
<p>The simplest instances of <code>Schema</code> are primitives, for example <code>Schema[String]</code>
represents the ability to encode and decode an arbitrary <code>String</code>.
The following primitives are supported:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>[<span class="hljs-type">Boolean</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">Long</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">Double</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">Float</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">Short</span>]
<span class="hljs-type">Schema</span>[<span class="hljs-type">AttributeValue</span>]
</code></pre>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li><code>Schema[AttributeValue]</code> is the identity schema that writes and
reads <code>AttributeValue</code> without touching it</li>
<li>Infamously, DynamoDB does not support empty strings. <code>dynosaur</code>
does not introduce any magic to deal with this automatically, but
it's flexible enough to allow you to handle this case in several
ways, including putting <code>NULL</code> or a special
value.<br>
Read on to learn about <code>imapErr</code>, <code>nullable</code> and all the other
combinators you can use to mold your data to fit your needs.</li>
</ul>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="bidirectional-mappings"></a><a href="#bidirectional-mappings" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bidirectional mappings</h2>
<p>New schemas can be created from existing ones by declaring a
bidirectional mapping between them.<br>
The most general way is using the <code>xmap</code> method on <code>Schema</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schema</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xmap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">ReadError</span>, <span class="hljs-type">B</span>])(g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">WriteError</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>]

</code></pre>
<p>although in many cases its two specialised variants <code>imap</code> and
<code>imapErr</code> are sufficient:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schema</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imap</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imapErr</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Either</span>[<span class="hljs-type">ReadError</span>, <span class="hljs-type">B</span>])(g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>]

</code></pre>
<p><code>imap</code> defines an isomorphism between <code>A</code> and <code>B</code>, which often arises
when using newtypes such as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventId</span>(<span class="hljs-params">value: <span class="hljs-type">String</span></span>)</span>
</code></pre>
<p>We would like to keep the specialised representation of <code>EventId</code> in
our code, but represent it as a simple <code>String</code> in Dynamo, without the
extra nesting.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> eventIdSchema = <span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>].imap(<span class="hljs-type">EventId</span>.apply)(_.value)
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">eventIdSchema.write(<span class="hljs-type">EventId</span>(<span class="hljs-string">"event-1234"</span>))
<span class="hljs-comment">// res4: io.circe.Json = {</span>
<span class="hljs-comment">//   "S" : "event-1234"</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p><code>imapErr</code> encodes the common case where encoding cannot fail but
decoding can, as seen, for example, in enums:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> dynosaur.codec.<span class="hljs-type">ReadError</span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Switch</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Switch</span> </span>{
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">On</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Switch</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Off</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Switch</span></span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span></span>: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">Switch</span>] = _.trim.toLowerCase <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"on"</span> =&gt; <span class="hljs-type">On</span>.some
    <span class="hljs-keyword">case</span> <span class="hljs-string">"off"</span> =&gt; <span class="hljs-type">Off</span>.some
    <span class="hljs-keyword">case</span> _ =&gt; none
  }
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">switchSchema</span> </span>= <span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>].imapErr { s =&gt;
   <span class="hljs-type">Switch</span>.parse(s).toRight(<span class="hljs-type">ReadError</span>()) <span class="hljs-comment">// TODO s"$s is not a valid Switch"</span>
 }(_.toString)
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> a = switchSchema.write(<span class="hljs-type">Switch</span>.<span class="hljs-type">On</span>)
<span class="hljs-comment">// a: io.circe.Json = {</span>
<span class="hljs-comment">//   "S" : "On"</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<h2><a class="anchor" aria-hidden="true" id="records"></a><a href="#records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Records</h2>
<p>Let's have a look at records with a case class example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">a: <span class="hljs-type">String</span>, b: <span class="hljs-type">Int</span></span>)</span>
</code></pre>
<p>whose <code>Schema[Foo]</code> can be defined as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fooSchema = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 (
   field(<span class="hljs-string">"a"</span>, _.a)(<span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>]),
   field(<span class="hljs-string">"b"</span>, _.b)(<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>])
 ).mapN(<span class="hljs-type">Foo</span>.apply)
}

</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">fooSchema.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"value of Foo"</span>, <span class="hljs-number">1</span>))
<span class="hljs-comment">// res5: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "a" : {</span>
<span class="hljs-comment">//       "S" : "value of Foo"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "b" : {</span>
<span class="hljs-comment">//       "N" : "1"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>The central component is <code>Schema.record</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
  ???
}
</code></pre>
<p>Which states that the type <code>Foo</code> is represented by a record, and gives
you the <code>field</code> builder to create fields by calling its various
methods. The primary method is <code>apply</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 <span class="hljs-keyword">val</span> b = field(<span class="hljs-string">"b"</span>, _.b)(<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>])
  
 ???
}
</code></pre>
<p>which takes three arguments:</p>
<ol>
<li>the name of the field in the resulting <code>AttributeValue</code></li>
<li>A function to access the field during the encoding phase, in this case <code>Foo =&gt; Int</code></li>
<li>the schema of the field, which is <code>Schema[Int]</code> is this case</li>
</ol>
<p>Once we have declared our fields, we need to tell <code>dynosaur</code> how to
combine them into a <code>Foo</code> during the decoding phase. Luckily, the
computations returned by <code>field.apply</code> are monadic, so we can use
<code>mapN</code> from cats:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 (
   field(<span class="hljs-string">"a"</span>,_.a)(<span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>]),
   field(<span class="hljs-string">"b"</span>, _.b)(<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>])
 ).mapN(<span class="hljs-type">Foo</span>.apply)
}
</code></pre>
<p>These definitions nest in the obvious way:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, foo: <span class="hljs-type">Foo</span></span>)</span>
<span class="hljs-keyword">val</span> nestedSchema: <span class="hljs-type">Schema</span>[<span class="hljs-type">Bar</span>] =
  <span class="hljs-type">Schema</span>.record { field =&gt;
   (
     field(<span class="hljs-string">"n"</span>, _.n)(<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>]),
     field(<span class="hljs-string">"foo"</span>, _.foo) {
       <span class="hljs-type">Schema</span>.record { field =&gt;
         (
          field(<span class="hljs-string">"a"</span>, _.a)(<span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>]),
          field(<span class="hljs-string">"b"</span>,_.b)(<span class="hljs-type">Schema</span>[<span class="hljs-type">Int</span>])
         ).mapN(<span class="hljs-type">Foo</span>.apply)
       }
     }
    ).mapN(<span class="hljs-type">Bar</span>.apply)
  }
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> bar = <span class="hljs-type">Bar</span>(<span class="hljs-number">10</span>, <span class="hljs-type">Foo</span>(<span class="hljs-string">"value of Foo"</span>, <span class="hljs-number">40</span>))
<span class="hljs-comment">// bar: Bar = Bar(10,Foo(value of Foo,40))</span>
nestedSchema.write(bar)
<span class="hljs-comment">// res9: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "n" : {</span>
<span class="hljs-comment">//       "N" : "10"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "foo" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "value of Foo"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "40"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li><code>record</code> is designed to help type inference as much as possible, but
you <strong>have</strong> to specify which type your schema is for, either with an
ascription or an annotation. If you don't do that, your
accessor functions inside <code>field</code> will not infer:
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> good = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt; ???}
<span class="hljs-keyword">val</span> alsoGood: <span class="hljs-type">Schema</span>[<span class="hljs-type">Foo</span>] = <span class="hljs-type">Schema</span>.record { field =&gt; ??? }
<span class="hljs-keyword">val</span> bad = <span class="hljs-type">Schema</span>.record { field =&gt; ??? }
</code></pre></li>
<li>You can name the builder that <code>record</code> gives you however you want
obviously, but <code>field</code> is nice and descriptive.</li>
</ul>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="implicit-vs-explicit-schemas-in-field"></a><a href="#implicit-vs-explicit-schemas-in-field" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implicit vs explicit schemas in <code>field</code></h3>
<p>In general, <code>Schema</code> is not a typeclass since there often are multiple
different encodings for the same type, but at the same time typing
<code>Schema[String]</code> everywhere for primitive types whose encoding hardly
if ever changes gets old quickly.
The <code>field</code> builder is designed to take the schema of the field as its
sole implicit argument, so that you can pass schemas implicitly or
explicitly at ease.</p>
<blockquote>
<p>The recommended guideline is to pass schemas for primitives
implicitly, and schemas for your own datatypes explicitly.</p>
</blockquote>
<p>This is how the previous schema would look like with the proposed
guideline:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Bar</span>] { field =&gt;
 (
   field(<span class="hljs-string">"n"</span>, _.n),
   field(<span class="hljs-string">"foo"</span>, _.foo) {
     <span class="hljs-type">Schema</span>.record { field =&gt;
       (
         field(<span class="hljs-string">"a"</span>, _.a),
         field(<span class="hljs-string">"b"</span>, _.b)
       ).mapN(<span class="hljs-type">Foo</span>.apply)
     }
   }
 ).mapN(<span class="hljs-type">Bar</span>.apply)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="additional-structure"></a><a href="#additional-structure" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional structure</h3>
<p>The monadic nature of the <code>field</code> builder allows to give additional
structure to the serialised record without affecting the code
representation. For example, given our <code>Foo</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">a: <span class="hljs-type">String</span>, b: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-keyword">val</span> fooSchema = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 (
   field(<span class="hljs-string">"a"</span>, _.a),
   field(<span class="hljs-string">"b"</span>, _.b)
 ).mapN(<span class="hljs-type">Foo</span>.apply)
}
</code></pre>
<p>We would like to produce a record that wraps <code>Foo</code> in an envelope
containing an <code>eventId</code> and a <code>payload</code>. We will take advantage of <code>*&gt;</code>, a
variant of <code>mapN</code> from <code>cats</code> which discards the left-hand side of an
applicative computation:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> randomEventId = <span class="hljs-string">"14tafet143ba"</span>
<span class="hljs-keyword">val</span> envelopeSchema = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
  field(<span class="hljs-string">"eventId"</span>, _ =&gt; randomEventId) *&gt; field(<span class="hljs-string">"payload"</span>, x =&gt; x)(fooSchema)
}
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">envelopeSchema.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"value of Foo"</span>, <span class="hljs-number">150</span>))
<span class="hljs-comment">// res12: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "eventId" : {</span>
<span class="hljs-comment">//       "S" : "14tafet143ba"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "payload" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "value of Foo"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "150"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>A particularly common scenario is wrapping an entire schema in a
record with a single key, so <code>dynosaur</code> exposes a <code>tag</code> method on
<code>Schema</code> for this purpose.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> taggedSchema = envelopeSchema.tag(<span class="hljs-string">"event"</span>)
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">taggedSchema.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"value of Foo"</span>, <span class="hljs-number">150</span>))
<span class="hljs-comment">// res13: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "event" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "eventId" : {</span>
<span class="hljs-comment">//           "S" : "14tafet143ba"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "payload" : {</span>
<span class="hljs-comment">//           "M" : {</span>
<span class="hljs-comment">//             "a" : {</span>
<span class="hljs-comment">//               "S" : "value of Foo"</span>
<span class="hljs-comment">//             },</span>
<span class="hljs-comment">//             "b" : {</span>
<span class="hljs-comment">//               "N" : "150"</span>
<span class="hljs-comment">//             }</span>
<span class="hljs-comment">//           }</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>Finally, it's worth specifying the meaning of <code>pure</code>, e.g. :</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>](_.pure(<span class="hljs-type">Foo</span>(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>)))
</code></pre>
<p>because we have never called <code>field.apply</code>, the resulting schema will
output the empty record during the encoding phase, and always succeed
with <code>Foo(&quot;a&quot;, 1)</code> during the decoding phase. As we will see later in
this document, this behaviour will prove useful when dealing with
objects in ADTs.</p>
<h3><a class="anchor" aria-hidden="true" id="constant-fields"></a><a href="#constant-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constant fields</h3>
<p>So far, decoding records has been entirely based on the <em>key</em> of each
field, letting the value be anything that can be converted to the
desired type. However, sometimes we need to assert that a field
contains a specific constant, and fail decoding if any other value is
found.<br>
Although this logic can be expressed entirely in terms of <code>field.apply</code> and
<code>imapErr</code>, <code>field</code> offers a dedicated method for this scenario,
<code>field.const</code>.<br>
For example, asserting that our <code>Foo</code> has <code>version: 1.0</code> is as simple as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> versionedFooSchema = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 field.const(<span class="hljs-string">"version"</span>, <span class="hljs-string">"1.0"</span>) *&gt; (
   field(<span class="hljs-string">"a"</span>, _.a),
   field(<span class="hljs-string">"b"</span>, _.b)
 ).mapN(<span class="hljs-type">Foo</span>.apply)
}
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">versionedFooSchema.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"value of Foo"</span>, <span class="hljs-number">300</span>))
<span class="hljs-comment">// res15: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "version" : {</span>
<span class="hljs-comment">//       "S" : "1.0"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "a" : {</span>
<span class="hljs-comment">//       "S" : "value of Foo"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "b" : {</span>
<span class="hljs-comment">//       "N" : "300"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>Note how the resulting record has a <code>version</code> field set to <code>1.0</code>, the
use of <code>const</code> guarantees that any other value will result in a
<code>ReadError</code>. Equality is performed using <code>==</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="case-classes-with-more-than-22-fields"></a><a href="#case-classes-with-more-than-22-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Case classes with more than 22 fields</h3>
<p>Scala's tuples have a hard limit of 22 elements, so if your case class has
more than 22 fields you won't be able to call <code>(f1, ..., f23).mapN</code>.<br>
Just use <code>for</code> for this case:</p>
<pre><code class="hljs css language-scala">record[<span class="hljs-type">BigClass</span>] { field =&gt;
  <span class="hljs-keyword">for</span> {
    f1 &lt;- field(...)
    ...
    f23 &lt;- field(...)
  } <span class="hljs-keyword">yield</span> <span class="hljs-type">BigClass</span>(f1, .., f23)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="optional-fields-nullable-values"></a><a href="#optional-fields-nullable-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional fields &amp; nullable values</h3>
<p>In order to fully capture the semantics of AttributeValue (which are
like JSON in this case), <code>dynosaur</code> draws a distinction between
<em>optional fields</em> and <em>nullable values</em>:</p>
<ul>
<li>An optional field may or may not be part of the serialised record,
but if it's there it cannot be <code>AttributeValue.NULL</code> for decoding to
succeed.</li>
<li>A nullable value can be <code>AttributeValue.NULL</code>, but it has to always
be part of the record for decoding to succeed. It can also appear
outside of records.</li>
</ul>
<p>As a general rule, optional fields should be preferred. They can be
constructed by calling the <code>opt</code> method on the <code>field</code> builder, which
is exactly like <code>field.apply</code> except for the accessor function which
has type <code>Record =&gt; Option[Field]</code> instead of <code>Record =&gt; Field</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span>(<span class="hljs-params">body: <span class="hljs-type">String</span>, topic: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>]</span>)</span>

<span class="hljs-keyword">val</span> msgSchemaOpt = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Msg</span>] { field =&gt;
 (
   field(<span class="hljs-string">"body"</span>, _.body),
   field.opt(<span class="hljs-string">"topic"</span>, _.topic)
 ).mapN(<span class="hljs-type">Msg</span>.apply)
}

</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">msgSchemaOpt.write(<span class="hljs-type">Msg</span>(<span class="hljs-string">"Topical message"</span>, <span class="hljs-string">"Interesting topic"</span>.some))
<span class="hljs-comment">// res16: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "body" : {</span>
<span class="hljs-comment">//       "S" : "Topical message"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "topic" : {</span>
<span class="hljs-comment">//       "S" : "Interesting topic"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
msgSchemaOpt.write(<span class="hljs-type">Msg</span>(<span class="hljs-string">"Random message"</span>, <span class="hljs-type">None</span>))
<span class="hljs-comment">// res17: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "body" : {</span>
<span class="hljs-comment">//       "S" : "Random message"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>To create a nullable value instead, use <code>field.apply</code> as normal, but
call <code>_.nullable</code> on the schema passed to it. If you are passing the
schema implicitly, just pass <code>Schema.nullable</code> instead:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> msgSchemaNull = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Msg</span>] { field =&gt;
 (
   field(<span class="hljs-string">"body"</span>, _.body),
   field(<span class="hljs-string">"topic"</span>, _.topic)(<span class="hljs-type">Schema</span>.nullable)
 ).mapN(<span class="hljs-type">Msg</span>.apply)
}

</code></pre>
<p>In this case, the call to <code>Schema.nullable</code> translates to <code>Schema[String].nullable</code>.</p>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">msgSchemaNull.write(<span class="hljs-type">Msg</span>(<span class="hljs-string">"Topical message"</span>, <span class="hljs-string">"Interesting topic"</span>.some))
<span class="hljs-comment">// res18: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "body" : {</span>
<span class="hljs-comment">//       "S" : "Topical message"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "topic" : {</span>
<span class="hljs-comment">//       "S" : "Interesting topic"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
msgSchemaNull.write(<span class="hljs-type">Msg</span>(<span class="hljs-string">"Random message"</span>, <span class="hljs-type">None</span>))
<span class="hljs-comment">// res19: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "body" : {</span>
<span class="hljs-comment">//       "S" : "Random message"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "topic" : {</span>
<span class="hljs-comment">//       "NULL" : true</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>Because of the choice between optionality and nullability, there
is no inductive implicit instance of <code>Schema</code> for <code>Option</code>. Schema
has an implicitNotFound annotation to warn you to use <code>opt</code> or
<code>nullable</code></li>
<li>If desired, one can be lenient and accept both missing and null fields.
The following code favours missing fields on writes, but accepts both on reads:
<pre><code class="hljs css language-scala">field
.opt(<span class="hljs-string">"topic"</span>, _.topic.map(_.some))(<span class="hljs-type">Schema</span>.nullable)
.map(_.flatten)
</code></pre>
whereas this one favours null fields on writes, equally accepting both on reads:
<pre><code class="hljs css language-scala">field
.opt(<span class="hljs-string">"topic"</span>, _.topic.some)(<span class="hljs-type">Schema</span>.nullable)
.map(_.flatten)
</code></pre>
These cases are rare enough, and at moment <code>dynosaur</code> does not offer a shortcut for them.</li>
</ul>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="coproducts"></a><a href="#coproducts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Coproducts</h2>
<p>Let's now move on to coproducts, by looking at this basic ADT:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Basic</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">One</span>(<span class="hljs-params">s: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Basic</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Two</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Basic</span></span>
</code></pre>
<p>with the corresponding schema:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> basicADTSchema = <span class="hljs-type">Schema</span>.oneOf[<span class="hljs-type">Basic</span>] { alt =&gt;
  <span class="hljs-keyword">val</span> one = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">One</span>]{ field =&gt; field(<span class="hljs-string">"s"</span>, _.s).map(<span class="hljs-type">One</span>.apply) }
  <span class="hljs-keyword">val</span> two = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Two</span>]{ field =&gt; field(<span class="hljs-string">"n"</span>, _.n).map(<span class="hljs-type">Two</span>.apply) }

  alt(one) |+| alt(two)
}
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> one = <span class="hljs-type">One</span>(<span class="hljs-string">"this is one"</span>)
<span class="hljs-comment">// one: One = One(this is one)</span>
<span class="hljs-keyword">val</span> two = <span class="hljs-type">Two</span>(<span class="hljs-number">4</span>)
<span class="hljs-comment">// two: Two = Two(4)</span>

basicADTSchema.write(one)
<span class="hljs-comment">// res20: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "s" : {</span>
<span class="hljs-comment">//       "S" : "this is one"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
basicADTSchema.read(basicADTSchema.write(one))
<span class="hljs-comment">// res21: Basic = One(this is one)</span>
basicADTSchema.write(two)
<span class="hljs-comment">// res22: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "n" : {</span>
<span class="hljs-comment">//       "N" : "4"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
basicADTSchema.read(basicADTSchema.write(two))
<span class="hljs-comment">// res23: Basic = Two(4)</span>
</code></pre>
<p></details></p>
<p>The definitions of <code>one</code> and <code>two</code> should be unsurprising, but we need
an additional combinator to express the concept of <em>choice</em>,
<code>Schema.oneOf</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.oneOf[<span class="hljs-type">Basic</span>] { alt =&gt; }
</code></pre>
<p>Which states that <code>Basic</code> is a coproducts of several alternatives,
defined through the <code>alt</code> builder. The computations returned by <code>alt</code>
are monoids, so we can combine them through <code>|+|</code> to mean &quot;orElse&quot;.
The <code>alt</code> builder takes two arguments:</p>
<ul>
<li><p>The schema of the alternative, for example <code>Schema[One]</code></p></li>
<li><p>An implicit <code>Prism[Basic, One]</code>, where <code>Prism</code> is defined by</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prism</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">tryGet: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>], inject: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span></span>)</span>
</code></pre></li>
</ul>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li><code>dynosaur</code> derives prisms automatically for ADTs, you don't need to do anything.</li>
<li>The same inference considerations of <code>record[Foo]</code> apply to <code>oneOf[Basic]</code>.</li>
<li>You need to make sure you handle all cases in <code>oneOf</code>, if you
forget to handle one, encoding will gracefully fail with a <code>WriteError</code>.</li>
</ul>
</blockquote>
<p>To see how the <code>Prism</code> shape arises when dealing with choice, consider this:</p>
<ul>
<li>When decoding, we need to always transform the variant we have
successfully decoded (e.g. <code>One</code>) into the coproduct (in this case
<code>Basic</code>). This can be expressed as <code>B =&gt; A</code></li>
<li>When encoding, for each case we need to check whether the coproduct
actually matches the given case (e.g. if it's <code>One</code> or not).  This
can be expressed as <code>A =&gt; Option[B]</code>.</li>
<li>A <code>Prism</code> packages these two functions into one entity, and gives us
a structure for composition: when encoding, we will do the
equivalent of pattern matching to select the right encoder. When
decoding, we will try each decoder until we find a successful one,
or fail if none of the alternatives successfully decodes our data.</li>
</ul>
<p>The semantics described above are enough to encode <em>choice</em>, but there
is a final issue to solve: <em>ambiguity</em>. Consider this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">v: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">v: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>

<span class="hljs-keyword">val</span> ambiguous: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">Schema</span>.oneOf { alt =&gt;
  <span class="hljs-keyword">val</span> b: <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">Schema</span>.record { field =&gt; field(<span class="hljs-string">"v"</span>, _.v).map(<span class="hljs-type">B</span>.apply) }
  <span class="hljs-keyword">val</span> c: <span class="hljs-type">Schema</span>[<span class="hljs-type">C</span>] = <span class="hljs-type">Schema</span>.record { field =&gt; field(<span class="hljs-string">"v"</span>, _.v).map(<span class="hljs-type">C</span>.apply) }

  alt(b) |+| alt(c)
}
</code></pre>
<p><code>a</code> needs to distinguish between <code>b</code> and <code>c</code> when decoding, but their
encoded form is the same:</p>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">ambiguous.write(<span class="hljs-type">B</span>(<span class="hljs-string">"hello"</span>))
<span class="hljs-comment">// res25: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "v" : {</span>
<span class="hljs-comment">//       "S" : "hello"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
ambiguous.write(<span class="hljs-type">C</span>(<span class="hljs-string">"hello"</span>))
<span class="hljs-comment">// res26: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "v" : {</span>
<span class="hljs-comment">//       "S" : "hello"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
ambiguous.read(ambiguous.write(<span class="hljs-type">C</span>(<span class="hljs-string">"hello"</span>))) <span class="hljs-comment">// gives incorrect result</span>
<span class="hljs-comment">// res27: A = B(hello)</span>
</code></pre>
<p></details></p>
<p><code>dynosaur</code> is expressing enough to solve this problem in several ways,
in this document we will have a look at two possible strategies:
<strong>discriminator keys</strong> and <strong>discriminator fields</strong>.</p>
<h3><a class="anchor" aria-hidden="true" id="discriminator-keys"></a><a href="#discriminator-keys" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Discriminator keys</h3>
<p>We will use this ADT as our running example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Problem</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">msg: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Problem</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Warning</span>(<span class="hljs-params">msg: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Problem</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Unknown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Problem</span></span>
</code></pre>
<p>and once again, <code>Error</code> and <code>Warning</code> exhibit ambiguity:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> err = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
  field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Error</span>.apply)
}
<span class="hljs-keyword">val</span> warn = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Warning</span>] { field =&gt;
  field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Warning</span>.apply)
}
</code></pre>
<p>The discriminator key strategy simply consists in wrapping each case
in a single-field record, whose key is the name of the case.
We have already seen a combinator that can do this, the <code>tag</code> method
on <code>Schema</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> err = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
  field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Error</span>.apply)
}.tag(<span class="hljs-string">"error"</span>)

<span class="hljs-keyword">val</span> warn = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Warning</span>] { field =&gt;
  field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Warning</span>.apply)
}.tag(<span class="hljs-string">"warning"</span>)
</code></pre>
<p>Now the two records have different keys (&quot;error&quot; vs &quot;warning&quot;), and
decoding is no longer ambiguous.<br>
The final question is how to encode <code>Unknown</code>, we need to <code>tag</code> a
schema that produces an empty record on encoding, and always succeeds
with <code>Unknown</code> on decoding, but as we saw in the <code>Additional structure</code> section, these are <em>exactly</em> the semantics of <code>field.pure</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> unknown = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Unknown</span>.<span class="hljs-keyword">type</span>](_.pure(<span class="hljs-type">Unknown</span>)).tag(<span class="hljs-string">"unknown"</span>)
</code></pre>
<p>The final schema looks like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> schemaWithKey = <span class="hljs-type">Schema</span>.oneOf[<span class="hljs-type">Problem</span>] { alt =&gt;
  <span class="hljs-keyword">val</span> err = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
    field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Error</span>.apply)
  }.tag(<span class="hljs-string">"error"</span>)

  <span class="hljs-keyword">val</span> warn = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Warning</span>] { field =&gt;
    field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Warning</span>.apply)
  }.tag(<span class="hljs-string">"warning"</span>)

  <span class="hljs-keyword">val</span> unknown = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Unknown</span>.<span class="hljs-keyword">type</span>] { field =&gt;
    field.pure(<span class="hljs-type">Unknown</span>)
  }.tag(<span class="hljs-string">"unknown"</span>)

  alt(err) |+| alt(warn) |+| alt(unknown)
}

</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> error = <span class="hljs-type">Error</span>(<span class="hljs-string">"this is an error"</span>)
<span class="hljs-comment">// error: Error = Error(this is an error)</span>
<span class="hljs-keyword">val</span> warning = <span class="hljs-type">Warning</span>(<span class="hljs-string">"this is a warning"</span>)
<span class="hljs-comment">// warning: Warning = Warning(this is a warning)</span>

schemaWithKey.write(error)
<span class="hljs-comment">// res31: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "error" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "msg" : {</span>
<span class="hljs-comment">//           "S" : "this is an error"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithKey.read(schemaWithKey.write(error))
<span class="hljs-comment">// res32: Problem = Error(this is an error)</span>
schemaWithKey.write(warning)
<span class="hljs-comment">// res33: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "warning" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "msg" : {</span>
<span class="hljs-comment">//           "S" : "this is a warning"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithKey.read(schemaWithKey.write(warning))
<span class="hljs-comment">// res34: Problem = Warning(this is a warning)</span>
schemaWithKey.write(<span class="hljs-type">Unknown</span>)
<span class="hljs-comment">// res35: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "unknown" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         </span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithKey.read(schemaWithKey.write(<span class="hljs-type">Unknown</span>))
<span class="hljs-comment">// res36: Problem = Unknown</span>
</code></pre>
<p></details></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>The discriminator key encoding is simple and convenient, but cannot
be used if your ADT is at the top level in your table, because
DynamoDB does not support attributes of type <code>M</code> as partition keys.</li>
</ul>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="discriminator-field"></a><a href="#discriminator-field" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Discriminator field</h3>
<p>In the discriminator field approach, each record adds an additional
field (for example called &quot;type&quot;) to disambiguate.<br>
The only thing to note is the use of <code>field.const</code> to make sure
decoding succeeds or fails based on the <em>specific value</em> of the field,
and not just the fact that there is a field called &quot;type&quot; whose value
is a <code>String</code>. The rest just uses straightforward combinators from cats:
<code>map</code>, <code>*&gt;</code>,<code>as</code>.</p>
<p>The schema looks like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> schemaWithField = <span class="hljs-type">Schema</span>.oneOf[<span class="hljs-type">Problem</span>] { alt =&gt;
  <span class="hljs-keyword">val</span> err = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
     field.const(<span class="hljs-string">"type"</span>, <span class="hljs-string">"error"</span>) *&gt; field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Error</span>.apply)
  }

  <span class="hljs-keyword">val</span> warn = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Warning</span>] { field =&gt;
    field.const(<span class="hljs-string">"type"</span>, <span class="hljs-string">"warning"</span>) *&gt; field(<span class="hljs-string">"msg"</span>, _.msg).map(<span class="hljs-type">Warning</span>.apply)
  }

  <span class="hljs-keyword">val</span> unknown = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Unknown</span>.<span class="hljs-keyword">type</span>] { field =&gt;
    field.const(<span class="hljs-string">"type"</span>, <span class="hljs-string">"unknown"</span>).as(<span class="hljs-type">Unknown</span>)
  }

  alt(err) |+| alt(warn) |+| alt(unknown)
}
</code></pre>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala">schemaWithField.write(error)
<span class="hljs-comment">// res37: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "type" : {</span>
<span class="hljs-comment">//       "S" : "error"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "msg" : {</span>
<span class="hljs-comment">//       "S" : "this is an error"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithField.read(schemaWithField.write(error))
<span class="hljs-comment">// res38: Problem = Error(this is an error)</span>
schemaWithField.write(warning)
<span class="hljs-comment">// res39: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "type" : {</span>
<span class="hljs-comment">//       "S" : "warning"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "msg" : {</span>
<span class="hljs-comment">//       "S" : "this is a warning"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithField.read(schemaWithField.write(warning))
<span class="hljs-comment">// res40: Problem = Warning(this is a warning)</span>
schemaWithField.write(<span class="hljs-type">Unknown</span>)
<span class="hljs-comment">// res41: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "type" : {</span>
<span class="hljs-comment">//       "S" : "unknown"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schemaWithField.read(schemaWithField.write(<span class="hljs-type">Unknown</span>))
<span class="hljs-comment">// res42: Problem = Unknown</span>
</code></pre>
<p></details></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>The same idea behind this encoding can be used for other scenarios
as well, for example you could use a <code>version</code> field in conjuction
with <code>alt</code> to support multiple versions of the same data in a
single table.</li>
</ul>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="sequences-and-maps"></a><a href="#sequences-and-maps" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sequences and Maps</h2>
<p><code>dynosaur</code> exposes implicit inductive instances for <code>List[A]</code>,
<code>Vector[A]</code> and <code>Seq[A]</code>, provided there is a <code>Schema[A]</code> in scope.
If you are passing schemas explicitly, you can call <code>asList</code>,
<code>asVector</code> or <code>asSeq</code> on a <code>Schema[A]</code> to obtain the corresponding
<code>Schema[Collection[A]]</code>.
The are all represented as <code>L</code> in <code>AttributeValue</code>:</p>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>[<span class="hljs-type">Vector</span>[<span class="hljs-type">Int</span>]].write(<span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
<span class="hljs-comment">// res43: io.circe.Json = {</span>
<span class="hljs-comment">//   "L" : [</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "N" : "1"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "N" : "2"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "N" : "3"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   ]</span>
<span class="hljs-comment">// }</span>
fooSchema.asList.write(<span class="hljs-type">List</span>(<span class="hljs-type">Foo</span>(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>), <span class="hljs-type">Foo</span>(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>), <span class="hljs-type">Foo</span>(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>)))
<span class="hljs-comment">// res44: io.circe.Json = {</span>
<span class="hljs-comment">//   "L" : [</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "a"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "1"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "b"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "2"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "c"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "3"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   ]</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<p>Note that bytes do not fit the above description: the library has
separate instances for <code>Array[Byte]</code> and <code>scodec.bits.ByteVector</code>, and
both are represented as <code>B</code> in <code>AttributeValue</code>. This requires the
bytes to be base 64 encoded/decoded , which is done automatically for
you.</p>
<p>As with sequences, there is an inductive instance of
<code>Schema[Map[String, A]]</code> given <code>Schema[A]</code>, also available by calling
<code>asMap</code> on a schema.</p>
<p><details>
<summary>Click to show the resulting AttributeValue</summary></p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>[<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>]].write(<span class="hljs-type">Map</span>(<span class="hljs-string">"hello"</span> -&gt; <span class="hljs-number">1</span>))
<span class="hljs-comment">// res45: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "hello" : {</span>
<span class="hljs-comment">//       "N" : "1"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
fooSchema.asMap.write(<span class="hljs-type">Map</span>(<span class="hljs-string">"A foo"</span> -&gt; <span class="hljs-type">Foo</span>(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>)))
<span class="hljs-comment">// res46: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "A foo" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "a"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "1"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p></details></p>
<blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>If you need to represent a Map whose keys aren't directly
<code>String</code>, but instead newtypes or enums, just use
<code>imap</code>/<code>imapErr</code>/<code>xmap</code> on the Map schema.</li>
</ul>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="byteset-stringset-and-numberset"></a><a href="#byteset-stringset-and-numberset" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ByteSet, StringSet and NumberSet</h2>
<p>TODO what to do about SS BS and NS?
NonEmpty vs what scanamo does (puts NULL, can conflict with Option)
implicit inductive instances on NonEmptySet[String], and NonEmptySet(numeric stuff), with corresponding as* methods
only on the appropriate schemas. If you have something you wish to represent as NS or SS, e.g. a
Set of newtypes, use imap appropriately on it (example with string sets?)</p>
<h2><a class="anchor" aria-hidden="true" id="section-with-expandable-examples-using-for-only"></a><a href="#section-with-expandable-examples-using-for-only" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Section with expandable examples using <code>for</code> only</h2>
<h2><a class="anchor" aria-hidden="true" id="inspiration"></a><a href="#inspiration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inspiration</h2>
<p>The approach of using <code>GADT</code>s for schemas and free constructions for
records was pioneered by the
<a href="https://github.com/nuttycom/xenomorph">xenomorph</a> library, however
the approach used here is different along at least two axes:</p>
<ul>
<li>It focuses on representing data in a specific format
(AttributeValue) rather than providing a schema to be reused for
multiple formats. This results in much greater control over the
data, and a simpler api for users.</li>
<li>The implementation differs in several aspects including improved
inference and a more flexible encoding of sums.</li>
</ul>
<p>The invariant combinators (<code>imap</code>, <code>imapErr</code>, <code>xmap</code>) and the
integration of implicit and explicit codecs is influenced by
<a href="https://github.com/scodec/scodec">scodec</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/dynosaur/docs/overview"><span class="arrow-prev">← </span><span>Overview</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#setup">Setup</a></li><li><a href="#quick-example">Quick example</a></li><li><a href="#motivation">Motivation</a></li><li><a href="#primitives">Primitives</a></li><li><a href="#bidirectional-mappings">Bidirectional mappings</a></li><li><a href="#records">Records</a><ul class="toc-headings"><li><a href="#implicit-vs-explicit-schemas-in-field">Implicit vs explicit schemas in <code>field</code></a></li><li><a href="#additional-structure">Additional structure</a></li><li><a href="#constant-fields">Constant fields</a></li><li><a href="#case-classes-with-more-than-22-fields">Case classes with more than 22 fields</a></li><li><a href="#optional-fields-nullable-values">Optional fields &amp; nullable values</a></li></ul></li><li><a href="#coproducts">Coproducts</a><ul class="toc-headings"><li><a href="#discriminator-keys">Discriminator keys</a></li><li><a href="#discriminator-field">Discriminator field</a></li></ul></li><li><a href="#sequences-and-maps">Sequences and Maps</a></li><li><a href="#byteset-stringset-and-numberset">ByteSet, StringSet and NumberSet</a></li><li><a href="#section-with-expandable-examples-using-for-only">Section with expandable examples using <code>for</code> only</a></li><li><a href="#inspiration">Inspiration</a></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright © 2018-2019 OVO Energy Limited.</section></footer></div></body></html>