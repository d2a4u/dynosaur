<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Encoding and decoding · Dynosaur</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;code&gt;Dynosaur&lt;/code&gt; design for codecs (pioneered by the&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Encoding and decoding · Dynosaur"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ovotech.github.io/dynosaur/dynosaur/"/><meta property="og:description" content="&lt;p&gt;&lt;code&gt;Dynosaur&lt;/code&gt; design for codecs (pioneered by the&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/dynosaur/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/dynosaur/js/scrollSpy.js"></script><link rel="stylesheet" href="/dynosaur/css/main.css"/><script src="/dynosaur/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/dynosaur/"><h2 class="headerTitle">Dynosaur</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/dynosaur/docs/overview" target="_self">Documentation</a></li><li class=""><a href="https://github.com/ovotech/dynosaur" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Documentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/dynosaur/docs/overview">Overview</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/dynosaur/docs/schema">Encoding and decoding</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Encoding and decoding</h1></header><article><div><span><p><code>Dynosaur</code> design for codecs (pioneered by the
<a href="https://github.com/nuttycom/xenomorph">xenomorph</a> library) is based
on defining <em>schemas</em> for your data, rather than your typical
<code>Encoder/Decoder</code> typeclasses.</p>
<p><strong>Note:</strong>  basic familiarity with <code>cats</code> typeclasses like <code>Monoid</code> and
<code>Applicative</code> is required.</p>
<h2><a class="anchor" aria-hidden="true" id="setup"></a><a href="#setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup</h2>
<p>We are going to need the following imports:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> dynosaur.codec.<span class="hljs-type">Schema</span>
<span class="hljs-keyword">import</span> cats.implicits._
</code></pre>
<p>We will also define some helpers to run the examples in this page, but
you are not going to need them in your own code.<br>
For the time being, we will ignore potential errors, and show the
output as <code>Json</code> instead of the <code>AttributeValue</code> ADT to help with
readability.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codecs</span>[<span class="hljs-type">A</span>](<span class="hljs-params">schema: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>]</span>) </span>{
  <span class="hljs-keyword">import</span> dynosaur.codec.{<span class="hljs-type">Encoder</span>, <span class="hljs-type">Decoder</span>}
  <span class="hljs-keyword">import</span> dynosaur.model.<span class="hljs-type">AttributeValue</span>
  <span class="hljs-keyword">import</span> dynosaur.lo.codec._
  <span class="hljs-keyword">import</span> io.circe._, syntax._
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span></span>(v: <span class="hljs-type">A</span>): <span class="hljs-type">Json</span> = 
    <span class="hljs-type">Encoder</span>.fromSchema(schema)
    .write(v)
    .map(_.asJson)
    .toOption.get
    
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(v: <span class="hljs-type">Json</span>): <span class="hljs-type">A</span> = {
    <span class="hljs-keyword">for</span> {
      av &lt;- v.as[<span class="hljs-type">AttributeValue</span>].toOption
      a &lt;- <span class="hljs-type">Decoder</span>.fromSchema(schema).read(av).toOption
    } <span class="hljs-keyword">yield</span> a
  }.get
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="quick-example"></a><a href="#quick-example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quick example</h2>
<p>Given this simple ADT</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Auth</span> </span>{
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">reason: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
}
</code></pre>
<p>We define a schema for it</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> schema: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = {
  <span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>._

  <span class="hljs-keyword">val</span> error = record[<span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>] { field =&gt;
    field(<span class="hljs-string">"reason"</span>, str, _.reason).map(<span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>.apply)
   }
   
  <span class="hljs-keyword">val</span> user = record[<span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>] { field =&gt;
    (
      field(<span class="hljs-string">"id"</span>, num, _.id),
      field(<span class="hljs-string">"name"</span>, str, _.name)
    ).mapN(<span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>.apply)
  }
  
  oneOf { alt =&gt;
    alt(tag(<span class="hljs-string">"error"</span>)(error)) |+| alt(tag(<span class="hljs-string">"user"</span>)(user)) 
  }
}
</code></pre>
<p>Which can then be used for both encoding and decoding</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> u = <span class="hljs-type">Auth</span>.<span class="hljs-type">User</span>(<span class="hljs-number">303</span>, <span class="hljs-string">"tim"</span>)
<span class="hljs-comment">// u: Auth.User = User(303,tim)</span>
<span class="hljs-keyword">val</span> e = <span class="hljs-type">Auth</span>.<span class="hljs-type">Error</span>(<span class="hljs-string">"Unauthorized"</span>)
<span class="hljs-comment">// e: Auth.Error = Error(Unauthorized)</span>

schema.write(u)
<span class="hljs-comment">// res0: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "user" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "id" : {</span>
<span class="hljs-comment">//           "N" : "303"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "name" : {</span>
<span class="hljs-comment">//           "S" : "tim"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schema.read(schema.write(u))
<span class="hljs-comment">// res1: Auth = User(303,tim)</span>
schema.write(e)
<span class="hljs-comment">// res2: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "error" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "reason" : {</span>
<span class="hljs-comment">//           "S" : "Unauthorized"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
schema.read(schema.write(e))
<span class="hljs-comment">// res3: Auth = Error(Unauthorized)</span>
</code></pre>
<p>In the rest of the document, we will only show encoding since decoding
comes for free, unless there is something specific to point out about
the behaviour of the decoder.</p>
<h2><a class="anchor" aria-hidden="true" id="motivation"></a><a href="#motivation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Motivation</h2>
<p>The typical approach most libraries use for codecs involves
<code>Encoder/Decoder</code> typeclasses, sometimes including automatic derivation.
This approach has the following drawbacks:</p>
<ul>
<li>Automatic derivation is useful, but it's not flexible enough to
cover many potential transformations you want to do on the serialised
data, like changing field names, flattening some records, adding
extra information, or have different encodings for sums types.</li>
<li>Writing explicit encoders and decoders is annoying because you need
to keep them in sync, and the required code is similar enough to be
tedious, but different enough to be error prone.<br>
Even without this duplication, the process is still made hard by the
fact that you are dealing with the practical details of traversing a
low level data structure like Json or AttributeValue.</li>
</ul>
<p>As a result, people abuse automatic derivation, and end up with either
ugly serialised data and a nice code model, or nice serialised data
and an ugly code model.<br>
The schema DSL provided by Dynosaur, on the other hand, allows you to
be flexible in how you define your serialised data, without
duplicating code for encoders and decoders, and with a declarative
focus on the <em>structure</em> of the data, rather than the traversal of a
low level representation.</p>
<h2><a class="anchor" aria-hidden="true" id="schema"></a><a href="#schema" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schema</h2>
<p>The central type of the DSL is <code>Schema[A]</code>, which you can think of as
either a representation of <code>A</code>, or a recipe for <em>both</em> encoding and
decoding <code>A</code>s to and from <code>AttributeValue</code>.
The simplest instances of <code>Schema</code> are primitives, for example <code>str</code>
represents the ability to encode and decode an arbitrary <code>String</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> strings: <span class="hljs-type">Schema</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Schema</span>.str
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="records"></a><a href="#records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Records</h3>
<p>Let's have a look at records with a case class example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">a: <span class="hljs-type">String</span>, b: <span class="hljs-type">Int</span></span>)</span>
</code></pre>
<p>whose <code>Schema[Foo]</code> can be defined as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fooSchema = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
 (
  field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
  field(<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b)
 ).mapN(<span class="hljs-type">Foo</span>.apply)
}

</code></pre>
<p>Resulting in the expected <code>AttributeValue</code> representation:</p>
<pre><code class="hljs css language-scala">fooSchema.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>))
<span class="hljs-comment">// res5: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "a" : {</span>
<span class="hljs-comment">//       "S" : "a"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "b" : {</span>
<span class="hljs-comment">//       "N" : "1"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>Let's unpack what's going on there.</p>
<ol>
<li><p>The first component is <code>field</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>.structure.{<span class="hljs-type">Ap</span>, <span class="hljs-type">Field</span>}

   <span class="hljs-keyword">val</span> fieldExample: <span class="hljs-type">Ap</span>[<span class="hljs-type">Field</span>[<span class="hljs-type">Foo</span>, ?], <span class="hljs-type">String</span>] =
     <span class="hljs-type">Schema</span>.field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a)
</code></pre>
<p>Which represents an <em>applicative computation</em> that accesses
fields of <code>Foo</code>, and returns <code>String.</code></p>
<p>Points to note:</p>
<ul>
<li><code>&quot;a&quot;</code> is the name of the field in the serialised <code>AttributeValue</code>.</li>
<li><code>Schema.str: Schema[String]</code> is the schema for the value of that
field. It says that you will get a <code>String</code> when decoding, which is
why <code>fieldExample</code> returns a <code>String</code> as a whole.</li>
<li><code>_.a</code> describes how to access the <code>a</code> field when given a
<code>Foo</code>. Because the value of the field is described by
<code>Schema.str</code>, <code>_.a</code> needs to return a <code>String</code> or you will get a
compile error.</li>
</ul>
<p>Another thing to point out is that the following will fail to compile,
because Scala is not able to infer that the argument of <code>_.a</code> is of
type <code>Foo</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> failedFieldExample = <span class="hljs-type">Schema</span>.field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a) 
<span class="hljs-comment">// error: missing parameter type for expanded function ((x$8: &lt;error&gt;) =&gt; x$8.a)</span>
<span class="hljs-comment">//    val failedFieldExample = Schema.field("a", Schema.str, _.a) </span>
<span class="hljs-comment">//                                                           ^</span>
</code></pre>
<p>You can annotate the function directly, but <code>field</code> uses the partially
applied type parameter trick as well.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> fieldExample = <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a)
</code></pre>
<p>We can define a field for <code>b</code> in a similar fashion.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>.structure.{<span class="hljs-type">Ap</span>, <span class="hljs-type">Field</span>}

   <span class="hljs-keyword">val</span> b: <span class="hljs-type">Ap</span>[<span class="hljs-type">Field</span>[<span class="hljs-type">Foo</span>, ?], <span class="hljs-type">Int</span>] = 
     <span class="hljs-type">Schema</span>.field(<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b)
</code></pre></li>
<li><p>The second step is the ability to say that if we can decode a field
named <code>&quot;a&quot;</code> as a <code>String</code>, and a field named <code>&quot;b&quot;</code> as an <code>Int</code>, we can
decode a <code>Foo</code>.
In pseudo-code:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Decoded</span>[<span class="hljs-type">String</span>]
<span class="hljs-type">Decoded</span>[<span class="hljs-type">Int</span>]
(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Foo</span>
----
<span class="hljs-type">Decoded</span>[<span class="hljs-type">Foo</span>]
</code></pre>
<p>This is exactly the shape that <code>cats.Applicative</code> encodes, and our
<code>field</code> returns applicative computations, which means we can do:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>.structure.{<span class="hljs-type">Ap</span>, <span class="hljs-type">Field</span>}

   <span class="hljs-keyword">val</span> foo: <span class="hljs-type">Ap</span>[<span class="hljs-type">Field</span>[<span class="hljs-type">Foo</span>, ?], <span class="hljs-type">Foo</span>] = 
    (
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b),
    ).mapN(<span class="hljs-type">Foo</span>.apply)
</code></pre>
<p>The <code>fields</code> constructor can turn the above into a <code>Schema[Foo]</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> foo: <span class="hljs-type">Schema</span>[<span class="hljs-type">Foo</span>] = <span class="hljs-type">Schema</span>.fields {
    (
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b),
    ).mapN(<span class="hljs-type">Foo</span>.apply)
   }
</code></pre></li>
<li><p>Finally, the schema for <code>foo</code> is a bit cluttered by all those <code>[Foo]</code>
ascriptions to help inference. You do need at least one due to
fundamental limitations of type inference in Scala, but the library
provides the <code>record</code> builder to minimise clutter for you.</p>
<p>The basic idea is that instead of writing</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> foo: <span class="hljs-type">Schema</span>[<span class="hljs-type">Foo</span>] = <span class="hljs-type">Schema</span>.fields {
    (
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
     <span class="hljs-type">Schema</span>.field[<span class="hljs-type">Foo</span>](<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b),
    ).mapN(<span class="hljs-type">Foo</span>.apply)
   }
</code></pre>
<p>You can write</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> foo: <span class="hljs-type">Schema</span>[<span class="hljs-type">Foo</span>] = <span class="hljs-type">Schema</span>.record { field =&gt;
    (
     field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
     field(<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b),
    ).mapN(<span class="hljs-type">Foo</span>.apply)
   }
</code></pre>
<p>You can even omit the type signature altogether as long as you
put a type ascription on <code>record</code>, which is how our initial example
schema looked like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> foo = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
    (
     field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
     field(<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b),
    ).mapN(<span class="hljs-type">Foo</span>.apply)
   }
</code></pre>
<p>Note that <code>field</code> there is the argument to the function passed to
<code>record</code>, and not <code>Schema.field</code>. If you prefer, you can rename that
to whatever you like.</p></li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="nested-records"></a><a href="#nested-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested records</h3>
<p>Nested records naturally correspond to nested schemas</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">n: <span class="hljs-type">Int</span>, foo: <span class="hljs-type">Foo</span></span>)</span>
<span class="hljs-keyword">val</span> nestedSchema: <span class="hljs-type">Schema</span>[<span class="hljs-type">Bar</span>] = {
  <span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>._
  <span class="hljs-comment">// we could also reuse the one defined above, of course</span>
  <span class="hljs-keyword">val</span> foo = record[<span class="hljs-type">Foo</span>] { field =&gt;
    (
      field(<span class="hljs-string">"a"</span>, str, _.a),
      field(<span class="hljs-string">"b"</span>, num, _.b)
    ).mapN(<span class="hljs-type">Foo</span>.apply)
  }
  
  record { field =&gt;
    (
     field(<span class="hljs-string">"n"</span>, num, _.n),
     field(<span class="hljs-string">"foo"</span>, foo, _.foo) <span class="hljs-comment">// we pass `foo` here</span>
    ).mapN(<span class="hljs-type">Bar</span>.apply)
  }
}
</code></pre>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> bar = <span class="hljs-type">Bar</span>(<span class="hljs-number">10</span>, <span class="hljs-type">Foo</span>(<span class="hljs-string">"value"</span>, <span class="hljs-number">40</span>))
<span class="hljs-comment">// bar: Bar = Bar(10,Foo(value,40))</span>
nestedSchema.write(bar)
<span class="hljs-comment">// res15: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "n" : {</span>
<span class="hljs-comment">//       "N" : "10"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "foo" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "a" : {</span>
<span class="hljs-comment">//           "S" : "value"</span>
<span class="hljs-comment">//         },</span>
<span class="hljs-comment">//         "b" : {</span>
<span class="hljs-comment">//           "N" : "40"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="flattening-records"></a><a href="#flattening-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Flattening records</h3>
<p>When modelling data in code, sometimes it's desirable to introduce newtypes
for extra precision:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span>(<span class="hljs-params">value: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">code: <span class="hljs-type">Int</span>, msg: <span class="hljs-type">Msg</span></span>)</span>
</code></pre>
<p>This would result in extra nesting in the AttributeValue, if encoded as shown
above</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> errMsg = <span class="hljs-type">Error</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Msg</span>(<span class="hljs-string">"problem"</span>))
<span class="hljs-comment">// errMsg: Error = Error(2,Msg(problem))</span>

<span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
 (
   field(<span class="hljs-string">"code"</span>, <span class="hljs-type">Schema</span>.num, _.code),
   field(
     <span class="hljs-string">"msg"</span>,
     <span class="hljs-type">Schema</span>.record[<span class="hljs-type">Msg</span>](_(<span class="hljs-string">"value"</span>, <span class="hljs-type">Schema</span>.str, _.value).map(<span class="hljs-type">Msg</span>.apply)),
     _.msg
   )
  ).mapN(<span class="hljs-type">Error</span>.apply)
}.write(errMsg)
<span class="hljs-comment">// res16: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "code" : {</span>
<span class="hljs-comment">//       "N" : "2"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "msg" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "value" : {</span>
<span class="hljs-comment">//           "S" : "problem"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>We'd like to keep the nesting in our code, but not in Dynamo.<br>
Here's one way to do it by changing the schema for <code>msg</code> to a <code>String</code>
and changing the accessor and constructor functions accordingly.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Error</span>] { field =&gt;
  (
    field(<span class="hljs-string">"code"</span>, <span class="hljs-type">Schema</span>.num, _.code),
    field(<span class="hljs-string">"msg"</span>, <span class="hljs-type">Schema</span>.str, _.msg.value)
  ).mapN((code, msg) =&gt; <span class="hljs-type">Error</span>(code, <span class="hljs-type">Msg</span>(msg)))
}.write(errMsg)
<span class="hljs-comment">// res17: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "code" : {</span>
<span class="hljs-comment">//       "N" : "2"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "msg" : {</span>
<span class="hljs-comment">//       "S" : "problem"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="extra-information"></a><a href="#extra-information" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extra information</h3>
<p>It's easy to add data to the serialised record that isn't present in
the code representation, because we have the entire <code>Applicative</code> api
at our disposal.<br>
Let's add a <code>version: 1.0</code> field to <code>Foo</code> using <code>*&gt;</code>, a variant of
<code>mapN</code> (also provided by <code>cats</code>) which discards the left-hand side.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Schema</span>.record[<span class="hljs-type">Foo</span>] { field =&gt;
  field(<span class="hljs-string">"version"</span>, <span class="hljs-type">Schema</span>.str, _ =&gt; <span class="hljs-string">"1.0"</span>) *&gt;
  (
    field(<span class="hljs-string">"a"</span>, <span class="hljs-type">Schema</span>.str, _.a),
    field(<span class="hljs-string">"b"</span>, <span class="hljs-type">Schema</span>.num, _.b)
  ).mapN(<span class="hljs-type">Foo</span>.apply)
}.write(<span class="hljs-type">Foo</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-number">345</span>))
<span class="hljs-comment">// res18: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "version" : {</span>
<span class="hljs-comment">//       "S" : "1.0"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "a" : {</span>
<span class="hljs-comment">//       "S" : "foo"</span>
<span class="hljs-comment">//     },</span>
<span class="hljs-comment">//     "b" : {</span>
<span class="hljs-comment">//       "N" : "345"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>In this case is worth specifying something with respect to decoding:
<code>field(&quot;version&quot;, Schema.str, _ =&gt; &quot;1.0&quot;)</code> means that the record
<em>must</em> contain a field named <code>&quot;version&quot;</code>, but that the contents of
that field can be <em>any</em> <code>String</code> (that's what <code>Schema.str</code> means),
even though when we serialise we put <code>&quot;1.0&quot;</code> there.<br>
Therefore, parsing <code>Foo</code> with the schema above will fail if the record
does not contain a field named <code>&quot;version&quot;</code>, but if it does it will
succeed no matter what the value of that field is, as long as it is a
<code>String</code>.<br>
Both the ability to assert that a field may not be there, and that the
value of a field should be a <em>specific</em> <code>String</code> (or anything else)
are useful, they are treated further down in this document.</p>
<h3><a class="anchor" aria-hidden="true" id="constants"></a><a href="#constants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constants</h3>
<h3><a class="anchor" aria-hidden="true" id="coproducts"></a><a href="#coproducts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Coproducts</h3>
<p>Since DynamoDB uses a JSON-like format, there are different ways to
encode coproducts. The recommended one looks like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">reason: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Error</span>] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">User</span>] = ???

<span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>._

<span class="hljs-keyword">val</span> schema: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = oneOf { alt =&gt;
  alt(tag(<span class="hljs-string">"error"</span>)(error)) |+| alt(tag(<span class="hljs-string">"user"</span>)(user))
}
</code></pre>
<p>The first thing we need to make this work is a way to go from
<code>Schema[Subtype]</code> to <code>Schema[Supertype]</code>, which we can do by
introducing the concept of a <code>Prism</code>.<br>
Let's focus on <code>Error</code> and <code>Auth</code>, starting with decoding: if you have
a <code>Decoder[Error]</code> and you need a <code>Decoder[Auth]</code>, it means that after
you decoded an <code>Error</code>, you need to transform it into an <code>Auth</code>, i.e.
you need a <code>Error =&gt; Auth</code>.<br>
The other direction however, is a bit different: if you have an
<code>Encoder[Error]</code> and you want to build an <code>Encoder[Auth]</code>, you first
need to figure out if the <code>Auth</code> you have is indeed an <code>Error</code> (and not a
<code>User</code>), and only then you can use the encoder for errors that you
have. This decision can be represented with a <code>Auth =&gt; Option[Error]</code>.</p>
<p>Given that a <code>Schema</code> needs to produce both an <code>Encoder</code> and a <code>Decoder</code>,
we need to have both functions, which as it turns out form a well-known
abstraction called <code>Prism</code>. <code>Dynosaur</code> defines a very simple <code>Prism</code> as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prism</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">tryGet: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">B</span>], inject: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span></span>)</span>
</code></pre>
<p>One can define <code>Prism</code>s for several things, but the one between an ADT
and one of its cases is particularly common and straighforward.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> dynosaur.codec.<span class="hljs-type">Prism</span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>

<span class="hljs-keyword">val</span> p: <span class="hljs-type">Prism</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = <span class="hljs-type">Prism</span>.fromPartial[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] {
  <span class="hljs-keyword">case</span> b: <span class="hljs-type">B</span> =&gt; b
}(b =&gt; b: <span class="hljs-type">A</span>)
</code></pre>
<p>In fact, it is so common that <code>Dynosaur</code> can derive it automatically
if you ask for one implicitly:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> dynosaur.codec.<span class="hljs-type">Prism</span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PrismExample</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Case1</span>(<span class="hljs-params">v: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismExample</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Case2</span>(<span class="hljs-params">i: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismExample</span></span>

<span class="hljs-keyword">val</span> c1: <span class="hljs-type">PrismExample</span> = <span class="hljs-type">Case1</span>(<span class="hljs-string">"hello"</span>)
<span class="hljs-comment">// c1: PrismExample = Case1("hello")</span>

<span class="hljs-keyword">val</span> p = implicitly[<span class="hljs-type">Prism</span>[<span class="hljs-type">PrismExample</span>, <span class="hljs-type">Case1</span>]]
<span class="hljs-comment">// p: Prism[PrismExample, Case1] = Prism(&lt;function1&gt;, &lt;function1&gt;)</span>

p.tryGet(c1).map(_.v)
<span class="hljs-comment">// res22: Option[String] = Some("hello")</span>
p.inject(<span class="hljs-type">Case1</span>(<span class="hljs-string">"yes"</span>))
<span class="hljs-comment">// res23: PrismExample = Case1("yes")</span>
p.tryGet(<span class="hljs-type">Case2</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// res24: Option[Case1] = None</span>
</code></pre>
<p>So we know how to write a schema for the individual cases, we know
that <code>Prism</code> encodes their relationship with the supertype, all that's
left is a concept of choice, which is expressed by the <code>alt</code>
constructor.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Chain</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>.structure.<span class="hljs-type">Alt</span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">reason: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Error</span>] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">User</span>] = ???

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">errorCase</span></span>: <span class="hljs-type">Chain</span>[<span class="hljs-type">Alt</span>[<span class="hljs-type">Auth</span>]] = <span class="hljs-type">Schema</span>.alt(error)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">userCase</span></span>: <span class="hljs-type">Chain</span>[<span class="hljs-type">Alt</span>[<span class="hljs-type">Auth</span>]] = <span class="hljs-type">Schema</span>.alt(user)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allCases</span></span>: <span class="hljs-type">Chain</span>[<span class="hljs-type">Alt</span>[<span class="hljs-type">Auth</span>]] = errorCase |+| userCase
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authSchema</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = <span class="hljs-type">Schema</span>.alternatives(allCases)
</code></pre>
<p>In the above snippet:</p>
<ul>
<li><code>Chain[Alt[Auth]]</code> is the type of computations that express <em>choice
between subtypes of <code>Auth</code></em>.</li>
<li><code>alt</code> takes as arguments the schema of the subtype and an implicit,
automatically derived <code>Prism</code>.</li>
<li>The <code>Monoid</code> instance for <code>Chain</code> expresses choice using <code>|+|</code> to mean &quot;or&quot;</li>
<li>The <code>Schema.alternatives</code> constructor builds a schema out of a set of choices</li>
</ul>
<p>When encoding, we will do the equivalent of pattern matching to select
the right encoder. When decoding, we will try each decoder until we
find a successful one, or fail if none of the alternatives
successfully decodes our data. In a following section we will see how
to minimise the work decoders have to do.</p>
<p><strong>Note</strong>: Unfortunately, it's up to you to make sure that you cover
all the cases of the ADT in your chain of <code>|+|</code>. If you don't,
encoding will graciously fail if you try to encode a case you have not
covered. We do not have a way to express the equivalent of a pattern
matching exhaustiveness check.</p>
<h3><a class="anchor" aria-hidden="true" id="inference"></a><a href="#inference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inference</h3>
<p>Similarly to products, coproducts expressed as above also suffer from
extra annotation clutter, and we employ a similar fix, compare
<code>clutter</code> to <code>noClutter</code> in the snippet below:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>(<span class="hljs-params">reason: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">id: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Auth</span></span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Error</span>] = ???
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">User</span>] = ???

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clutter</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = <span class="hljs-type">Schema</span>.alternatives {
  <span class="hljs-type">Schema</span>.alt[<span class="hljs-type">Auth</span>](error) |+| <span class="hljs-type">Schema</span>.alt[<span class="hljs-type">Auth</span>](user)
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">noClutter</span></span>: <span class="hljs-type">Schema</span>[<span class="hljs-type">Auth</span>] = <span class="hljs-type">Schema</span>.oneOf { alt =&gt;
  alt(error) |+| alt(user)
}

<span class="hljs-comment">// note the [Auth] annotation</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">noClutter2</span> </span>= <span class="hljs-type">Schema</span>.oneOf[<span class="hljs-type">Auth</span>] { alt =&gt;
  alt(error) |+| alt(user)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tagging"></a><a href="#tagging" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tagging</h3>
<p>In the example above we simply composed the schemas of the subtypes
with <code>|+|</code>, with no further modifications.<br>
This can work in simple cases, but it has two drawbacks:</p>
<ul>
<li>A decoder might have to do a lot of work decoding a bunch of fields,
before realising it needs to fallback to the next one.</li>
<li>It's not possible to distinguish between two cases with the same
representation.</li>
</ul>
<p>Here is a quick example of the second issue:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">v: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">v: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>

<span class="hljs-keyword">val</span> ambiguous: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">Schema</span>.oneOf { alt =&gt;
  <span class="hljs-keyword">val</span> b: <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">Schema</span>.record { field =&gt;
   field(<span class="hljs-string">"v"</span>, <span class="hljs-type">Schema</span>.str, _.v).map(<span class="hljs-type">B</span>.apply)
  }
  <span class="hljs-keyword">val</span> c: <span class="hljs-type">Schema</span>[<span class="hljs-type">C</span>] = <span class="hljs-type">Schema</span>.record { field =&gt;
   field(<span class="hljs-string">"v"</span>, <span class="hljs-type">Schema</span>.str, _.v).map(<span class="hljs-type">C</span>.apply)
  }
  
  alt(b) |+| alt(c)
}
</code></pre>
<p><code>a</code> needs to distinguish between <code>b</code> and <code>c</code> when decoding, but their encoded form is the same:</p>
<pre><code class="hljs css language-scala">ambiguous.write(<span class="hljs-type">B</span>(<span class="hljs-string">"hello"</span>))
<span class="hljs-comment">// res27: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "v" : {</span>
<span class="hljs-comment">//       "S" : "hello"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
ambiguous.write(<span class="hljs-type">C</span>(<span class="hljs-string">"hello"</span>))
<span class="hljs-comment">// res28: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "v" : {</span>
<span class="hljs-comment">//       "S" : "hello"</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>Therefore we need a way to <em>tag</em> each schema before using <code>|+|</code> to
clearly distinguish between them. As a bonus, the decoder has to do
(potentially a lot) less work because it can fallback to the next case
after analysing only the tag, instead of the whole record.</p>
<p>There are various strategies for tagging, the one we recommend is to
create a record with one key corresponding to the name of the
coproduct case, like so:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> tagged: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">Schema</span>.oneOf { alt =&gt;
  <span class="hljs-comment">// same as before</span>
  <span class="hljs-keyword">val</span> b: <span class="hljs-type">Schema</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">Schema</span>.record { field =&gt;
   field(<span class="hljs-string">"v"</span>, <span class="hljs-type">Schema</span>.str, _.v).map(<span class="hljs-type">B</span>.apply)
  }
  <span class="hljs-keyword">val</span> c: <span class="hljs-type">Schema</span>[<span class="hljs-type">C</span>] = <span class="hljs-type">Schema</span>.record { field =&gt;
   field(<span class="hljs-string">"v"</span>, <span class="hljs-type">Schema</span>.str, _.v).map(<span class="hljs-type">C</span>.apply)
  }
  <span class="hljs-comment">// but we tag them</span>
  <span class="hljs-keyword">val</span> taggedB = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">B</span>] { field =&gt;
    field(<span class="hljs-string">"b"</span>, b, x =&gt; x)
  }
  <span class="hljs-keyword">val</span> taggedC = <span class="hljs-type">Schema</span>.record[<span class="hljs-type">C</span>] { field =&gt;
    field(<span class="hljs-string">"c"</span>, c, x =&gt; x)
  }
  <span class="hljs-comment">// using the tags</span>
  alt(taggedB) |+| alt(taggedC)
}
</code></pre>
<p>Which results in correct behaviour:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> out = tagged.write(<span class="hljs-type">B</span>(<span class="hljs-string">"hello"</span>))
<span class="hljs-comment">// out: io.circe.Json = {</span>
<span class="hljs-comment">//   "M" : {</span>
<span class="hljs-comment">//     "b" : {</span>
<span class="hljs-comment">//       "M" : {</span>
<span class="hljs-comment">//         "v" : {</span>
<span class="hljs-comment">//           "S" : "hello"</span>
<span class="hljs-comment">//         }</span>
<span class="hljs-comment">//       }</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>
tagged.read(out)
<span class="hljs-comment">// res29: A = B(hello)</span>
</code></pre>
<p>This is common enough to be worth a <code>tag</code> combinator, which is what
you saw in the initial example.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">Schema</span>._

<span class="hljs-keyword">val</span> betterTagged: <span class="hljs-type">Schema</span>[<span class="hljs-type">A</span>] = oneOf { alt =&gt;
  <span class="hljs-keyword">val</span> b = record[<span class="hljs-type">B</span>] { field =&gt;
   field(<span class="hljs-string">"v"</span>, str, _.v).map(<span class="hljs-type">B</span>.apply)
  }
  <span class="hljs-keyword">val</span> c = record[<span class="hljs-type">C</span>] { field =&gt;
   field(<span class="hljs-string">"v"</span>, str, _.v).map(<span class="hljs-type">C</span>.apply)
  }
  
  alt(tag(<span class="hljs-string">"b"</span>)(b)) |+| alt(tag(<span class="hljs-string">"c"</span>)(c))
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="flexible-tagging"></a><a href="#flexible-tagging" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Flexible tagging</h3>
<p>The tagging schema above is the recommended one, but by no means the
only way to do it, here is another common way by having a record with
a field named &quot;type&quot; to discriminate, and a field &quot;payload&quot; for the
actual content.</p>
<p>TODO once I have constants</p>
<h3><a class="anchor" aria-hidden="true" id="encoding-objects"></a><a href="#encoding-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Encoding objects</h3>
<p>You can encode object as empty records or Strings</p>
<h3><a class="anchor" aria-hidden="true" id="optional"></a><a href="#optional" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional</h3>
<p>When reading if will retun None on <code>Nil</code> or missing key, when writing you decide</p>
<h3><a class="anchor" aria-hidden="true" id="defaults-on-error"></a><a href="#defaults-on-error" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defaults on error</h3>
<p>withDefault</p>
<h3><a class="anchor" aria-hidden="true" id="sequences"></a><a href="#sequences" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sequences</h3>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/dynosaur/docs/overview"><span class="arrow-prev">← </span><span>Overview</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#setup">Setup</a></li><li><a href="#quick-example">Quick example</a></li><li><a href="#motivation">Motivation</a></li><li><a href="#schema">Schema</a><ul class="toc-headings"><li><a href="#records">Records</a></li><li><a href="#nested-records">Nested records</a></li><li><a href="#flattening-records">Flattening records</a></li><li><a href="#extra-information">Extra information</a></li><li><a href="#constants">Constants</a></li><li><a href="#coproducts">Coproducts</a></li><li><a href="#inference">Inference</a></li><li><a href="#tagging">Tagging</a></li><li><a href="#flexible-tagging">Flexible tagging</a></li><li><a href="#encoding-objects">Encoding objects</a></li><li><a href="#optional">Optional</a></li><li><a href="#defaults-on-error">Defaults on error</a></li><li><a href="#sequences">Sequences</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright © 2018-2019 OVO Energy Limited.</section></footer></div></body></html>